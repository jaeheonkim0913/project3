#!/usr/bin/env python3

import argparse
import copy
from itertools import combinations
from operator import truediv
import socket
import time
import json
import select
import struct
import sys
import math


def ipToBin(ip: str) -> str:
    tmp = ip.split('.')
    for x in tmp:
        format(int(x), '08b')
    return ''.join(list(tmp))


def binToIp(bin: str):
    return '.'.join(map(lambda tmp: str(int(tmp, 2)), [bin[i:i+8] for i in range(0, 31, 8)]))


class Router:

    relations = {}
    sockets = {}
    ports = {}
    routingTable = {}
    routingTableLog = []
    withdrawLog = []

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")

            self.sockets[neighbor] = socket.socket(
                socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            # handshake
            self.send(neighbor, json.dumps({"type": "handshake", "src": self.our_addr(
                neighbor), "dst": neighbor, "msg": {}}))

    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        self.sockets[network].sendto(message.encode(
            'utf-8'), ('localhost', self.ports[network]))

    # updating forwarding table, and also saving a copy of data
    def updateTable(self, src, data):
        self.routingTableLog.append(data)
        if src not in self.routingTable:
            self.routingTable[src] = []
        self.routingTable[src].append(data['msg'])
        self.aggregate()

    # handling route announcement messages
    def announce(self, src, data, update):
        def forwardMessage(dst):

            if update:
                tmpUpdate = copy.deepcopy(data['msg'])
                tmpUpdate['ASPath'].insert(0, self.asn)
                tmpUpdate.pop('localpref', None)
                tmpUpdate.pop('origin', None)
                tmpUpdate.pop('selfOrigin', None)
            else:
                tmpUpdate = data['msg']
            packet = {
                'src': self.our_addr(dst),
                'dst': dst,
                'type': 'update' if update else 'withdraw',
                'msg': tmpUpdate
            }
            return json.dumps(packet)

        for h in self.sockets.keys():
            # second part assumed true
            if h != src and (self.relations[h] == 'cust' or self.relations[src] == 'cust'):
                self.send(h, forwardMessage(h))

    def withdraw(self, data):
        self.withdrawLog.append(data)
        updateMsg = list(map(lambda update: update['msg'], list(
            filter(lambda update: update['src'] == data['src'], self.routingTableLog))))
        withdrawLists = list(map(lambda withdraw: withdraw['msg'], list(
            filter(lambda withdraw: withdraw['src'] == data['src'], self.withdrawLog))))
        withdraw = ([withdrawItem for srcWdList in withdrawLists
                     for withdrawItem in srcWdList])
        for withdrawNetwork, withdrawNetmask in map(lambda wdItem: wdItem.values(), withdraw):
            updateMsg = ([msg for msg in updateMsg
                          if msg['network'] != withdrawNetwork or msg['netmask'] != withdrawNetmask])
        self.routingTable[data['src']] = updateMsg
        self.aggregate(target=data['src'])

    def sendData(self, src, packet):
        # Match the destination network prefix with all entries in the routing table
        def matchPrefix(dst):
            matches = []
            for neighbor, routes in self.routingTable.items():
                for route in routes:
                    dstBin = ipToBin(dst)
                    networkBin = ipToBin(route['network'])
                    netmaskBin = ipToBin(route['netmask'])
                    matchingLength = 0
                    for mask, expect, actual in zip(netmaskBin, networkBin, dstBin):
                        mask = int(mask)
                        expect = int(expect)
                        actual = int(actual)
                        if bool(mask) and (expect == actual):
                            matchingLength += 1
                        elif bool(mask) and (expect != actual):
                            # Abort the match
                            break
                        else:
                            matches.append((neighbor, matchingLength, route))
                            # Terminate the match
                            break
            # The returned list consists of tuples of neighbor connection address, the length of
            # the matched prefix, and the route meta information
            return matches

        # Find the best forwarding route
        def findBestRoute(matches):
            # to find the logest prefix match(es)
            longestMatchLength = max(list(map(lambda x: x[1], matches)))
            bestRoutes = list(
                filter(lambda x: x[1] == longestMatchLength, matches))
            if len(bestRoutes) == 1:
                return bestRoutes[0]
            # to find highest local preference match(es)
            bestLocalPref = max(
                list(map(lambda x: x[2]['localpref'], bestRoutes)))
            bestRoutes = list(
                filter(lambda x: x[2]['localpref'] == bestLocalPref, bestRoutes))
            if len(bestRoutes) == 1:
                return bestRoutes[0]
            # to find self origin routes
            selfOriginRoutes = list(
                filter(lambda x: x[2]['selfOrigin'], bestRoutes))
            bestRoutes = selfOriginRoutes if selfOriginRoutes else bestRoutes
            if len(bestRoutes) == 1:
                return bestRoutes[0]
            # to find routes that via shortest AS path
            shortestASPath = min(
                list(map(lambda x: len(x[2]['ASPath']), bestRoutes)))
            bestRoutes = list(filter(lambda x: len(
                x[2]['ASPath']) == shortestASPath, bestRoutes))
            if len(bestRoutes) == 1:
                return bestRoutes[0]
            # to find routes that have preferred origin
            igpRoutes = list(
                filter(lambda x: x[2]['origin'] == "IGP", bestRoutes))
            egpRoutes = list(
                filter(lambda x: x[2]['origin'] == "EGP", bestRoutes))
            unkRoutes = list(
                filter(lambda x: x[2]['origin'] == "UNK", bestRoutes))
            # let best routes be the first non-empty preferred list
            bestRoutes = igpRoutes if igpRoutes else (
                egpRoutes if egpRoutes else unkRoutes)
            if len(bestRoutes) == 1:
                return bestRoutes[0]
            # default fall back to find the lowest neighbor IP address
            return min(bestRoutes, key=lambda x: x[0])

        # Compose a message that notifies the sender our router cannot route the message
        def composeNoRouteMessage():
            noRoutePacket = {
                'src': self.our_addr(src),
                'dst': packet['src'],
                'type': "no route",
                "msg": {}
            }
            return json.dumps(noRoutePacket)

        # find all possible routes by matching the prefix of the destination of the message
        dst = packet['dst']
        matches = matchPrefix(dst)

        # if no available route, send back a no-route message
        if not matches:
            dst = src
            msg = composeNoRouteMessage()
        # otherwise find the best route and get the network address
        else:
            dst = findBestRoute(matches)[0]
            msg = json.dumps(packet)
        # if neither the destination or the source is a customer, we stop fowarding the message,
        # and send back a no-route message
        if (self.relations[dst] != 'cust' and self.relations[src] != 'cust'):
            dst = src
            msg = composeNoRouteMessage()
        self.send(dst, msg)

    def dump(self, src):
        def expandRoutingTable(routingTable):
            expanded = []
            for neighbor, routes in routingTable.items():
                for route in routes:
                    expanded.append((neighbor, route))
            # The returned list consists of pairs of neighbor connection address and
            # the route information
            return expanded

        data = list(map(lambda entry: {
            "peer": entry[0],
            "network": entry[1]["network"],
            "netmask": entry[1]["netmask"],
            "localpref": entry[1]["localpref"],
            "origin": entry[1]["origin"],
            "selfOrigin": entry[1]["selfOrigin"],
            "ASPath": entry[1]["ASPath"],
        }, expandRoutingTable(self.routingTable)))
        table = {
            "src": self.our_addr(src),
            "dst": src,
            "type": "table",
            "msg": data
        }
        msg = json.dumps(table)
        self.send(src, msg)

    def aggregate(self, target=None):

        if (target):
            aggregateTargets = [target]
        else:
            aggregateTargets = self.routingTable.keys()
        for neighbor in aggregateTargets:
            for i in range(len(self.routingTable[neighbor]) - 1):
                flag = False
                curRoutes = self.routingTable[neighbor]
                for (neighborOne, neighborTwo) in list(combinations(curRoutes, 2)):
                    if (neighborOne['origin'] == neighborTwo['origin']
                       and neighborOne['selfOrigin'] == neighborTwo['selfOrigin']
                       and neighborOne['localpref'] == neighborTwo['localpref']
                       and neighborOne['ASPath'] == neighborTwo['ASPath']
                       and neighborOne['netmask'] == neighborTwo['netmask']):
                        # same prefix?
                        tmp = ipToBin(neighbor['network']).rfind('1')
                        if (ipToBin(neighborOne['network'])[:tmp] == ipToBin(neighborTwo['network'])[:tmp]):
                            netmaskNeighborOne = ipToBin(
                                neighborOne['netmask']).rfind('1')
                            aggregateBackToIP = binToIp(ipToBin(neighborOne['netmask'])[
                                                        :netmaskNeighborOne] + '0' + ipToBin(neighborOne['netmask'])[netmaskNeighborOne + 1:])

                            if neighborOne['network'] < neighborTwo['network']:
                                lowNet = neighborOne['network']
                            else:
                                lowNet = neighborTwo['network']

                            result = {
                                'network': lowNet,
                                'netmask': aggregateBackToIP,
                                'localpref': neighborOne['localpref'],
                                'origin': neighborOne['origin'],
                                'selfOrigin': neighborOne['selfOrigin'],
                                'ASPath': neighborOne['ASPath'],
                            }
                            self.routingTable[neighbor].append(result)
                            self.routingTable[neighbor].remove(neighborOne)
                            self.routingTable[neighbor].remove(neighborTwo)
                            flag = True
                            break
                if not flag:
                    break

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')

                print("Received message '%s' from %s" % (msg, srcif))

                data = json.loads(msg)
                type = data['type']
                if type == 'update':
                    self.updateTable(srcif, data)
                    self.announce(srcif, data, True)
                elif type == 'withdraw':
                    self.withdraw(data)
                    self.announce(srcif, data, False)
                elif type == 'data':
                    self.sendData(srcif, data)
                elif type == 'dump':
                    self.dump(srcif)
                else:
                    raise Exception("invalid data type error")
        return


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections',
                        type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()
